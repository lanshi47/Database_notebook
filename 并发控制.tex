\section{并发控制}
\subsection{并发控制的基本概念}
并发控制：通过锁机制（悲观控制）或多版本控制（乐观控制）确保事务的一致性和隔离性。\\
封锁：在悲观控制中，事务对数据项加锁，防止其他事务同时访问导致数据不一致。\\
数据不一致性:
\begin{enumerate}
    \item 丢失更新
    \item 脏读
    \item 不可重复读
    \item 幻读
\end{enumerate}
\subsection{封锁的基本概念}
排他锁（X锁/写锁）：事务加锁后禁止其他事务对该数据项进行读写。\\
共享锁（S锁/读锁）：允许其他事务同时加共享锁读取，但禁止加排他锁进行写操作。\\

\subsection{封锁协议}
\begin{enumerate}
    \item 一级封锁协议：事务对数据项加锁后，直到事务结束才释放锁。
    \item 严格两段锁协议（Strict 2PL）：事务在整个执行期间只在结束时统一释放所有锁，避免脏读问题。
    \item 两段锁协议（2PL）：事务分为加锁阶段和解锁阶段，加锁阶段期间不释放锁，进入解锁阶段后不能再申请新锁。
\end{enumerate}
\subsection{活锁和死锁}
活锁：多个事务不断响应彼此的请求，导致无法有效推进。\\
死锁：多个事务形成相互等待关系，导致系统僵持。\\
死锁处理方法：
\begin{enumerate}
    \item 死锁检测：构建等待图，检测循环依赖。
    \item 死锁恢复：通过回滚部分事务解除死锁。
    \item 死锁预防：采用资源排序、一次性申请所有资源等策略。
\end{enumerate}
\subsection{可串行化调度}
可串行化调度：事务执行顺序经过调整后效果等同于某一串行顺序，保证数据的一致性。\\

\subsection{两段锁协议(2PL)}
两段锁协议：事务执行分为加锁阶段（不释放任何锁）和解锁阶段（统一释放所有锁）。\\

\subsection{多版本并发控制（MVCC）}
多版本并发控制：通过保存数据的多个版本，使得读操作无需等待写锁，从而提高并发性能。常见于乐观并发控制策略。\\

